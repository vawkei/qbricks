# Scaffolding:
Got inside the frontend folder:
```bash
cd frontend
```
result:
```bash
PS C:\Users\Voke Sokoh\Documents\visual_testing\react\qbricks\frontend>
```

initialized the project inside frontend:
```bash
 npm create vite@latest .
```
response:
```bash
 npx
> create-vite .
```
Selected react as framework:
```bash
â—†  Select a framework:
â—‡  Select a framework:
â”‚  React
```

Selected Typescript as variant:
```bash
â—‡  Select a variant:
â”‚  TypeScript
```
Didnt select rolldown:
```bash
 Use rolldown-vite (Experimental)?:
â”‚  No
â”‚
```
After all that:
```bash
â—‡  Scaffolding project in C:\Users\Voke Sokoh\Documents\visual_testing\react\qbricks\frontend...
â”‚
â—‡  Installing dependencies with npm...

added 176 packages, and audited 177 packages in 44s

45 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
â”‚
â—‡  Starting dev server...

> frontend@0.0.0 dev
> vite


  VITE v7.3.1  ready in 2235 ms

  âžœ  Local:   http://localhost:5173/
  âžœ  Network: use --host to expose
  âžœ  press h + enter to show help
```

# Installan of some frontend Packages:  

So for me to work, I will need some packages or should i say dependencies. tio

I installed these; react-query, sass and react-router-dom:
```bash
npm install @tanstack/react-query react-router-dom sass
```

# Changing of Ports
I changed the port in which the frontend will be running on from:

```bash
http://localhost:5173/
```
to:
```bash
http://localhost:3000/
```
in the vite.config.ts file:
```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server:{
    port:3000
  }
})
```
So if i run:
```bash
 npm run dev
```
I get this in the terminal:
```bash
  VITE v7.3.1  ready in 422 ms

  âžœ  Local:   http://localhost:3000/
  âžœ  Network: use --host to expose
  âžœ  press h + enter to show help
```

# The about section:

Created the About section, and it had these:
# SECTION: The Problem with Exam Preparation Today
**1ï¸âƒ£ â€œMost exam prep tools focus on content dumps and not true assessmentsâ€**
**What it means:**
Many platforms just upload notes, PDFs, or video lessons. They prioritize content delivery, not performance testing.

**Investor explanation:**
Most edtech products are content-first (watch, read, consume). But exams measure performance under pressure. QBricks is assessment-first â€” we simulate the actual evaluation environment.

**2ï¸âƒ£ â€œStudents practice without understanding why answers are wrongâ€**
**What it means:**
Students often see a score, but donâ€™t get structured feedback explaining their mistakes clearly.
**Investor explanation:**
Feedback quality is low in traditional prep tools. Either they show only correct answers, or explanations are generic. QBricks integrates AI to provide targeted correction logic per mistake.

**3ï¸âƒ£ â€œExams test performance, but prep tools rarely simulate performanceâ€**
**What it means:**
Exams measure:
Speed
Accuracy
Time pressure
Decision-making

Most tools donâ€™t replicate that environment realistically.

**Investor explanation:**
We focus on performance simulation, not just learning material. That includes timed questions, structured flow, and post-test analytics. We train students to perform â€” not just consume.

# SECTION: How QBricks is Different
**1ï¸âƒ£ â€œStart with real exam-style questionsâ€**
**What it means:**
Instead of teaching theory first, we start with actual past-question structure.

**Investor explanation:**
We reverse the traditional learning order. Instead of â€œlearn â†’ then test,â€ we go â€œtest â†’ then diagnose â†’ then correct.â€ This aligns with how exams actually work.

**2ï¸âƒ£ â€œUse AI to explain mistakes clearlyâ€**
**What it means:**
AI doesnâ€™t replace teachers. It explains why an answer is wrong and why another is correct â€” immediately and personally.

**Investor explanation:**
The differentiation isnâ€™t just AI usage. Itâ€™s AI-driven mistake diagnosis per student attempt, enabling scalable individualized correction.

**3ï¸âƒ£ â€œMeasure performance, not just lesson completionâ€**
**What it means:**
We donâ€™t track:
- Videos watched
- Notes completed

We track:
- Score

- Topic weaknesses

- Accuracy per section

- Improvement over time

**Investor explanation:**
Engagement metrics are vanity. Performance metrics are outcome-based. QBricks optimizes for exam results, not platform activity.

**4ï¸âƒ£ â€œExams test performance. QBricks simulates performance.â€**
**What it means:**
We are building an environment that mirrors the real exam experience.

**Investor explanation:**
Simulation reduces exam anxiety and improves readiness. We position ourselves closer to exam-condition rehearsal than traditional e-learning.


# SECTION: What QBricks Offers Right Now
**1ï¸âƒ£ â€œJAMB Styled past questions practiceâ€**
**What it means:**
Weâ€™re starting with JAMB-like question sets and structure.

**Investor explanation:**
We are launching with a focused market (JAMB candidates) instead of a broad, diluted offering. Narrow beachhead strategy.

**2ï¸âƒ£ â€œAI powered explanationsâ€**
**What it means:**
After test attempts, AI provides structured correction and explanation.

**Investor explanation:**
AI scales personalized feedback without requiring human tutors, improving margins and accessibility.

**3ï¸âƒ£ â€œEarly stage classroomâ€**
**What it means:**
Phase 2 exists as a guided AI-based understanding layer, but itâ€™s still evolving.

Investor explanation:
We are building progressively:
Phase 1 = Assessment engine
Phase 2 = AI understanding layer


1. â€œMeasure performance, not just lesson completion.â€
Meaning: QBricks focuses on how well a student can actually answer exam questions â€” not just whether they finished reading content.

2. â€œExams test performance. QBricks simulates performance.â€
Meaning: Real exams measure how you perform under pressure.
QBricks is designed to simulate that exact performance environment before the real exam.





# Created the Backend Folder

Created the backend folder and then immediately ran:
```bash
 npm init -y
```
response:
```bash
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
```
# Git init:
then when out of the backend folder by typing:
```bash
cd ..
```
now i am in:
```bash
C:\Users\Voke Sokoh\Documents\visual_testing\react\qbricks>
```

Initialized git for the project by typing:
```bash
git init
```
response:
```bash
Initialized empty Git repository in C:/Users/Voke Sokoh/Documents/visual_testing/react/qbricks/.git/
```
Staged the files and foilders:
```bash
git add .
```

Made the first commit:
```bash
git commit -m "initial commit"
```
# Pushing to GitHub:
pushed it to github with the master branch:
```bash
git push origin master
```

# Auth: Created the register and login Form.
Nothing serious here. Created an Auth.tsx file and a sibling for it, Auth.module.scss which is used to handle styling.

The Auth.tsx has this content:

**State management**
```js
  const [enteredName, setEnteredName] = useState("");
  const [enteredEmail, setEnteredEmail] = useState("");
  const [enteredPassword, setEnteredPassword] = useState("");
  const [confirmedPassword, setConfirmedPassword] = useState("");
  const [haveAccount, setHaveAccount] = useState(false);
```

**Switch between register and login mode**
```js
const switchAuthModeHandler = () => {
    setHaveAccount((currState) => !currState);
  };
```

**onSumit Function**
this is the basis, light validation takes place here:
```js
const onSubmitHandler = (event: React.ChangeEvent) => {
    event.preventDefault();

    if (haveAccount) {
      //ðŸ‘‡ðŸ‘‡ =========================== Logging===============================ðŸ‘‡ðŸ‘‡
      if (
        enteredEmail.trim().length === 0 ||
        enteredPassword.trim().length < 6
      ) {
        return console.log("fill inputs accordingly");
      }

      const userData: UserProps = {
        email: enteredEmail,
        password: enteredPassword,
      };

      console.log(userData);
    } else {
      //ðŸ‘‡ðŸ‘‡ =================Register=============================ðŸ‘‡ðŸ‘‡
      if (enteredName.trim().length < 3) {
        return console.log("name should be at least 3 characters long");
      }
      if (enteredEmail.trim().length === 0) {
        return console.log("please enter valid email address");
      }
        if(!enteredEmail.includes("@")){
            return console.log("please enter valid email address")
        }
      if (enteredPassword.trim().length < 6) {
        return console.log("password must be at least 6 characters long");
      }

      const userData: UserProps = {
        name: enteredName,
        email: enteredEmail,
        password: enteredPassword,
        confirmedPassword: confirmedPassword,
      };
      console.log(userData)
    }
  };
```

Then the jsx is returned below.

# Auth Api: http requests for authentication

Created a folder called apis in the src folder and then created a file called auth-api in it. 
This file has three functions that makes http requests to three endpoints at the backend folder.

**register endpoint**

this is the backend end point i am hitting:
```js
const BACKEND_URL = "http://localhost:5000/api/v1/auth";
```

```js
export const register = async (userData: UserProps) => {
  try {
    const response = await fetch(`${BACKEND_URL}/register`, {
      method: "POST",
      body: JSON.stringify(userData),
      headers: { "Content-Type": "application/json" },
      credentials: "include",
    });

    const data = response.json();
    console.log("data:", data);

    if (!response.ok) {
      // throw new Error(data.msg || "request failed")
      throw new Error();
    }

    return data;
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "something went wrong";
    console.log("registerError:", message);
  }
};
```
This function is responsible for making request to the register endpoint


**login**
still in the auth-api.ts file, I wrote out this function to make a http request to the login route:
```js
export const login = async (userData: UserProps) => {
  try {
    const response = await fetch(`${BACKEND_URL}/login`, {
      method: "POST",
      body: JSON.stringify(userData),
      headers: { "Content-Type": "application/json" },
      credentials: "include",
    });

    const data = response.json();
    console.log("data:", data);

    if (!response.ok) {
      throw new Error();
      // throw new Error (data.msg || "request failed")
    }

    return data;
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "something went wrong";
    console.log("loginError:", message);
  }
};
```

**logout**
this function handles the logout request on the backend:
```js
export const logout = async () => {
  try {
    const response = await fetch(`${BACKEND_URL}/logout`);
    const data = response.json();
    console.log("data:", data);

    if (!response.ok) {
      throw new Error();
    }
    return data;
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "something went wrong";
    console.log("logoutError:", message);
  }
};
```


# Back to the Backend:
Navigated to the backend folder. So right now i am on this path:
```bash
PS C:\Users\Voke Sokoh\Documents\visual_testing\react\qbricks\backend>
```

Quickly installed the following packages:
```bash
npm install cors express jsonwebtoken typescript bcryptjs dotenv mongoose cookie-parser
```
Explanation 
These are TypeScript type definition packages for popular Node.js libraries.  

They do not run your app. They help your editor and compiler understand the shape of the code.  

Think of TypeScript as a very strict proofreader.  

Libraries like Express or JWT are written in normal JavaScript, so TypeScript says:  

â€œI donâ€™t know what functions these libraries have or what kind of data they expect.â€  

These @types/... packages are instruction manuals for TypeScript.

Installed these also:
**Nodemon**
```bash
npm install nodemon
```
**installed TypeScript type definitions for Node.js.**
```bash
npm install @types/node
```
What that means

Node.js has built-in globals like:

process

__dirname

Buffer

require

fs, path, etc.

But TypeScript doesnâ€™t know their types by default.

Without @types/node, youâ€™ll see errors like:
```bash
Cannot find name 'process'
Cannot find module 'fs'
```


**Also ran this for types:**
```bash
npm install --save-dev @types/express @types/cors @types/cookie-parser @types/jsonwebtoken
```

```bash
npm install -D ts-node ts-node-dev
```
**created a new tsconfig.json file**
```bash
npx tsc --init
```

# index.ts and middlewares:
After installing all the necessary packages I would be using, I created the src folder in the root directory of the backend folder. Inside the src, I created a file called index.ts.

Then I created a folder in the src called middlewares. In there i made two files. One called errorHandlerMiddleware and the other, notFoundMiddleware.

**errorHandlerMiddleware**

code:
```js
import { Request, Response, NextFunction } from "express";

export const errorHandlerMiddleware = (
  error: unknown,
  req: Request,
  res: Response,
  _next: NextFunction,
) => {
  const message = error;
  console.log("error message from errorHandlerMiddleware:", message);

  res
    .status(500)
    .json({
      msg: error instanceof Error ? error.message : "something went wrong",
    });
  return;
};
```
**notFoundMiddleware**

code:
```js
import { Request,Response } from "express";

export const notFoundMiddleware = (_req:Request,res:Response)=>{
    const message = "Route doesn't exist..."

   res.status(404).json({msg:message});
   return
};
```

Then in the index.ts file I had this as my base set up to start the server:

```js
import express from "express";
import cors from "cors";
import "dotenv/config";
import mongoose from "mongoose";
import cookieParser from "cookie-parser";
import { errorHandlerMiddleware } from "./middlewares/errorHandlerMiddleware";
import { notFoundMiddleware } from "./middlewares/notFoundMiddleware";
```
mongoose is imported there eventhough i dont need it right now.

then the other parts in the file are as follows:
```js
const app = express();

const corsOptions = {
  origin: ["http://localhost:3000"],
  credentials: true,
  methods: ["GET", "POST", "PATCH", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization", "my-custom-header"],
};

// number 1:
app.use(cors(corsOptions));

// number 2:
app.use(cookieParser());

// number 3"
app.use(express.json());

// route:
app.get("/",(_req,res)=>{
    res.send("This is QBricks server...")
});



app.use(errorHandlerMiddleware);
app.use(notFoundMiddleware);


const PORT = Number(process.env.PORT) || 5000; 

// startup server without database:
const start = ()=>{
    app.listen(PORT,"localhost",()=>{
        console.log(`server listening on ${PORT}`)
    })
};

start();
```

# Starting up the server:
With all those, I tried starting up the server by running:
```bash
npm run dev
```
But i got hit with:
```bash
npm error Missing script: "dev"
npm error
npm error To see a list of scripts, run:
npm error   npm run
npm error A complete log of this run can be found in: C:\Users\Voke Sokoh\AppData\Local\npm-cache\_logs\2026-02-14T03_37_48_910Z-debug-0.log
```
Error is glaring there, saying Missing script.
To solve it, I went to my package.json and switched the script there to this:
```bash
"scripts": {
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "start": "npm run build && node dist/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
```

started it again by running:
```bash
npm run dev
```

Then i got this in the terminal:
```bash
> backend@1.0.0 dev
> nodemon src/index.ts

[nodemon] 3.1.11
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: ts,json
[nodemon] starting `ts-node src/index.ts`
server listening on 5000
```
Good, this means the backend is up and running...